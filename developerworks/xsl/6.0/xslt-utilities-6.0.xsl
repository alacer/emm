<?xml version="1.0"?>
<!-- 
   The source code contained herein is licensed under the IBM International
   License Agreement for Non-Warranted Sample Code.  
   Copyright (C) 2001, 2003, 2011 International Business Machines Corporation
   All Rights Reserved.
  -->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:fo="http://www.w3.org/1999/XSL/Format" exclude-result-prefixes="xsl fo">

    <!-- IBS 2012-02-06 Moved xsl:template name="CheckCodeSectionLineLength" from dw-common -->
    <!--  Checks line lengths in codes sections. Code to be checked is obtained by applying templates with a parameter to omit generation of elements such as <b>, <span>, etc, but to include special characters such as Ã†,Ã¨,Ã¿, etc, generated by templates. -->
    <!-- *****USED for 6.0 -->
    <xsl:template name="CheckCodeSectionLineLength">
        <xsl:param name="code-to-check"/>
        <!--<xsl:param name="code-to-output" />-->
        <xsl:param name="indent-chars" select="0"/>
        <xsl:param name="check-type" select=" 'calculate' "/>
        <xsl:choose>
            <xsl:when test="contains($code-to-check, '&#10;') ">
                <xsl:variable name="line-length">
                    <xsl:call-template name="CalculateCodeLineLength">
                        <xsl:with-param name="code-to-check"
                            select="substring-before(string($code-to-check), '&#10;' )"/>
                        <xsl:with-param name="indent-chars" select="$indent-chars"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="($check-type = 'calculate') and
                        ($line-length &gt; $max-code-line-length)">
                        <xsl:value-of select="$line-length"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="$check-type = 'error-message' ">
                            <xsl:value-of select="substring-before($code-to-check,
                                '&#10;' )"/>
                            <xsl:text>&#10;</xsl:text>
                            <!-- Maverick 6.0 R2 jpp-egd 06/18/09:  Reinstating the too long code length error message -->
                            <xsl:if test="$line-length &gt; $max-code-line-length">
                                <span style="margin-top: 0; margin-bottom: 0;
                                    font-family: Andale Mono, Lucida Console, Monaco,
                                    fixed, monospace;  font-size: 11px;  color: #ff0000">
                                    <xsl:value-of select="concat( '|',
                                        substring(substring($code-ruler, 1,
                                        $max-code-line-length - 2), 1+$indent-chars),
                                        '|')"/>
                                </span>
                                <xsl:value-of select="'&#10;'"/>
                                <xsl:call-template name="DisplayError">
                                    <xsl:with-param name="error-number"
                                        >e001</xsl:with-param>
                                    <xsl:with-param name="display-format"
                                        >inline</xsl:with-param>
                                </xsl:call-template>
                                <xsl:value-of select="'&#10;'"/>
                            </xsl:if>
                        </xsl:if>
                        <xsl:call-template name="CheckCodeSectionLineLength">
                            <xsl:with-param name="code-to-check"
                                select="substring-after($code-to-check,
                                '&#10;' )"/>
                            <xsl:with-param name="indent-chars" select="$indent-chars"/>
                            <xsl:with-param name="check-type" select="$check-type"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="string-length($code-to-check) &gt; 0">
                    <xsl:variable name="line-length">
                        <xsl:call-template name="CalculateCodeLineLength">
                            <xsl:with-param name="code-to-check" select="$code-to-check"/>
                            <xsl:with-param name="indent-chars" select="$indent-chars"/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:choose>
                        <xsl:when test="$check-type = 'calculate'">
                            <xsl:value-of select="$line-length"/>
                        </xsl:when>
                        <xsl:when test="$check-type = 'error-message'">
                            <xsl:value-of select="$code-to-check"/>
                            <!-- Maverick 6.0 R2 jpp-egd 06/18/09:  Reinstating the too long code length error message -->
                            <xsl:if test="$line-length &gt; $max-code-line-length">
                                <span style="margin-top: 0; margin-bottom: 0;
                                    font-family: Andale Mono, Lucida Console, Monaco,
                                    fixed, monospace;  font-size: 11px;  color: #ff0000">
                                    <xsl:value-of select="'&#10;'"/>
                                    <xsl:value-of select="concat( '|',
                                        substring(substring($code-ruler, 1,
                                        $max-code-line-length - 2), 1+$indent-chars),
                                        '|')"/>
                                </span>
                                <xsl:value-of select="'&#10;'"/>
                                <xsl:call-template name="DisplayError">
                                    <xsl:with-param name="error-number"
                                        >e001</xsl:with-param>
                                    <xsl:with-param name="display-format"
                                        >inline</xsl:with-param>
                                </xsl:call-template>
                                <xsl:value-of select="'&#10;'"/>
                            </xsl:if>
                        </xsl:when>
                    </xsl:choose>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!-- IBS 2012-02-06 Moved xsl:template name="CalculateCodeLineLength" from dw-common -->
    <!-- *****USED for 6.0 -->
    <xsl:template name="CalculateCodeLineLength">
        <xsl:param name="code-to-check"/>
        <xsl:param name="indent-chars" select="0"/>
        <xsl:choose>
            <xsl:when test="not(contains($code-to-check, '&#09;' ))">
                <xsl:value-of select="$indent-chars + string-length($code-to-check)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="CalculateCodeLineLength">
                    <xsl:with-param name="code-to-check"
                        select="substring-after($code-to-check,               '&#09;' )"/>
                    <xsl:with-param name="indent-chars" select="($tab-stop-width *
                        floor(($indent-chars +
                        string-length(substring-before($code-to-check, '&#09;')) +
                        $tab-stop-width) div               $tab-stop-width))"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- Calculate the number of lines in a code section omitting leading empty lines -->
    <xsl:template name="CalculateCodeLineCount">
        <xsl:param name="code-to-check"/>
        <xsl:choose>
            <xsl:when test="normalize-space($code-to-check) = '' ">
                <xsl:value-of select="0"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="total-line-feeds"
                    select="string-length($code-to-check) -
                    string-length(translate($code-to-check, '&#0010;&#0013;', '' ))"/>
                <xsl:variable name="first-non-white-space"
                    select="substring(normalize-space($code-to-check), 1,1)"/>
                <xsl:variable name="leading-line-feeds"
                    select="string-length(substring-before($code-to-check,
                    $first-non-white-space)) -
                    string-length(translate(substring-before($code-to-check,
                    $first-non-white-space ), '&#0010;&#0013;', '' ))"/>
                <xsl:value-of select="$total-line-feeds - $leading-line-feeds"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- IBS 2012-02-06 Moved xsl:template name="DisplayError" from dw-common -->
    <!-- *****USED for 6.0 -->
    <!-- DisplayError for general XSL error handling -->
    <xsl:template name="DisplayError">
        <xsl:param name="error-number"/>
        <xsl:param name="display-format"/>
        <!-- Assign error text variable based on error number -->
        <xsl:variable name="error-text">
            <xsl:choose>
                <xsl:when test="$error-number = 'e001'">
                    <xsl:value-of select="$e001"/>
                </xsl:when>
                <xsl:when test="$error-number = 'e002'">
                    <xsl:value-of select="$e002"/>
                </xsl:when>
                <xsl:when test="$error-number = 'e003'">
                    <xsl:value-of select="$e003"/>
                </xsl:when>
                <xsl:when test="$error-number = 'e004'">
                    <xsl:value-of select="$e004"/>
                </xsl:when>
                <xsl:when test="$error-number = 'e005'">
                    <xsl:value-of select="$e005"/>
                </xsl:when>
                <!-- 6.0 Maverick R2 11 30 09 (tdc):  Added e006  -->
                <xsl:when test="$error-number = 'e006'">
                    <xsl:value-of select="$e006"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$e999"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <!-- Display the error text per the passed format -->
        <xsl:choose>
            <xsl:when test="$display-format = 'inline'">
                <xsl:choose>
                    <!-- Special case:  I have to match the code section font for error e001 -->
                    <xsl:when test="$error-number = 'e001'">
                        <span style="margin-top: 0; margin-bottom: 0; font-family: Andale
                            Mono, Lucida Console, Monaco, fixed, monospace; font-size:
                            11px; color: #ff0000">
                            <xsl:value-of select="$error-text"/>
                        </span>
                    </xsl:when>
                    <xsl:otherwise>
                        <span style="color: #ff0000">
                            <xsl:value-of select="$error-text"/>
                        </span>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$display-format = 'table'">
                <table border="1">
                    <tr>
                        <td style="color: #ff0000">
                            <xsl:value-of select="$error-text"/>
                        </td>
                    </tr>
                </table>
            </xsl:when>
        <xsl:when test="$display-format ='pdf'">
                <fo:inline color="red">
                            <xsl:value-of select="$error-text"/>
                </fo:inline>
            </xsl:when>
        </xsl:choose>
        <!--  Choose block to display errors on console and terminate
     on final transform with long line length for publication date 2008 and later -->
        <xsl:choose>
            <xsl:when test="($xform-type = 'final' ) and ($error-number = 'e001') and
                (//date-published/@year &gt;= 2008)">
                <xsl:message terminate="yes">
                    <xsl:value-of select="$error-text"/>
                </xsl:message>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="no">
                    <xsl:value-of select="$error-text"/>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>


    <!-- Use DPI with caution! Web graphics use 72. 
        Some stuff uses 96. 
        Print  really needs about 300 to look decent -->
    <xsl:param name="dpi" select="72"/>
    <xsl:variable name="pixels-per-inch" select="$dpi"/>
    <xsl:variable name="picas-per-inch" select="6"/>
    <xsl:variable name="points-per-inch" select="72"/>
    <xsl:variable name="mm-per-inch" select="25.4"/>
    <xsl:variable name="mm-per-cm" select="10"/>
    <xsl:variable name="twips-per-inch" select="1440"/>
    <xsl:variable name="didot-points-per-mm" select="1 div 0.376065"/>
    <xsl:variable name="to-inches" select=" 'in' "/>
    <xsl:variable name="to-mm" select=" 'mm' "/>
    <xsl:variable name="to-cm" select=" 'cm' "/>
    <xsl:variable name="to-picas" select=" 'pica' "/>
    <xsl:variable name="to-points" select=" 'pt' "/>
    <xsl:variable name="to-didot-points" select=" 'dpt' "/>
    <xsl:variable name="to-pixels" select=" 'px' "/>

    <!-- IBS 2011-09-15 Split this out in case we ever want to use the input measurement unit for something
    else. Might be handy to be able to do percentages too. -->
    <xsl:template name="extract-measurement-units">
        <xsl:param name="in-value"/>
        <xsl:param name="default-units"/>
        <xsl:choose>
            <xsl:when test="(normalize-space($in-value) = '') or
                (normalize-space($in-value) = 0) ">
                <xsl:value-of select="$default-units"/>
            </xsl:when>
            <xsl:when test="contains($in-value, 'mm')">
                <xsl:value-of select=" 'mm' "/>
            </xsl:when>
            <xsl:when test="contains($in-value, 'cm')">
                <xsl:value-of select=" 'cm' "/>
            </xsl:when>
            <xsl:when test="contains($in-value, 'in')">
                <xsl:value-of select=" 'in' "/>
            </xsl:when>
            <xsl:when test="contains($in-value, 'dpt')">
                <xsl:value-of select=" 'dpt' "/>
            </xsl:when>
            <xsl:when test="contains($in-value, 'pt')">
                <xsl:value-of select=" 'pt' "/>
            </xsl:when>
            <xsl:when test="contains($in-value, 'pica')">
                <xsl:value-of select=" 'pica' "/>
            </xsl:when>
            <xsl:when test="contains($in-value, 'twip')">
                <xsl:value-of select=" 'twip' "/>
            </xsl:when>
            <xsl:when test="contains($in-value, 'px')">
                <xsl:value-of select=" 'px' "/>
            </xsl:when>
            <xsl:otherwise>
                <!--  Not sure how to get export filter messages to display anywhere!!  -->
                <xsl:message>convert-measurement-units: No conversion rule found for
                        <xsl:value-of select="$in-value"/></xsl:message>
                <xsl:value-of select="unknown"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="convert-measurement-units">
        <xsl:param name="in-value"/>
        <xsl:param name="to-units"/>
        <xsl:variable name="to-units-clean" select="normalize-space($to-units)"/>
        <xsl:variable name="from-units">
            <xsl:call-template name="extract-measurement-units">
                <xsl:with-param name="default-units" select="$to-units-clean"/>
                <xsl:with-param name="in-value" select="$in-value"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="from-units1">
            <xsl:choose>
                <xsl:when test="(normalize-space($in-value) = '') or
                    (normalize-space($in-value) = 0) ">
                    <xsl:value-of select="$to-units-clean"/>
                </xsl:when>
                <xsl:when test="contains($in-value, 'mm')">
                    <xsl:value-of select=" 'mm' "/>
                </xsl:when>
                <xsl:when test="contains($in-value, 'cm')">
                    <xsl:value-of select=" 'cm' "/>
                </xsl:when>
                <xsl:when test="contains($in-value, 'in')">
                    <xsl:value-of select=" 'in' "/>
                </xsl:when>
                <xsl:when test="contains($in-value, 'dpt')">
                    <xsl:value-of select=" 'dpt' "/>
                </xsl:when>
                <xsl:when test="contains($in-value, 'pt')">
                    <xsl:value-of select=" 'pt' "/>
                </xsl:when>
                <xsl:when test="contains($in-value, 'pica')">
                    <xsl:value-of select=" 'pica' "/>
                </xsl:when>
                <xsl:when test="contains($in-value, 'twip')">
                    <xsl:value-of select=" 'twip' "/>
                </xsl:when>
                <xsl:when test="contains($in-value, 'px')">
                    <xsl:value-of select=" 'px' "/>
                </xsl:when>
                <xsl:otherwise>
                    <!--  Not sure how to get export filter messages to display anywhere!!  -->
                    <xsl:message>convert-measurement-units: No conversion rule found for
                            <xsl:value-of select="$in-value"/></xsl:message>
                    <xsl:value-of select="unknown"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <!-- Make sure empty in-value converts to 0 magnitude with type same as to-units by
        concatenating 0 before as marker -->
        <xsl:variable name="m1" select="concat('0', normalize-space($in-value),
            $from-units)"/>
        <xsl:variable name="m2" select="substring-before($m1, $from-units )"/>
        <xsl:variable name="m3" select="number($m2) "/>


        <xsl:variable name="magnitude" select="number(substring-before(concat('0',
            normalize-space($in-value), $from-units), $from-units )) "/>
        <xsl:choose>
            <xsl:when test="$from-units = $to-units-clean">
                <xsl:value-of select="$magnitude"/>
            </xsl:when>
            <xsl:when test="$from-units = 'unknown' ">
                <xsl:value-of select="$in-value"/>
            </xsl:when>
            <xsl:when test="$from-units = 'mm' and $to-units-clean = 'cm' ">
                <xsl:value-of select="$magnitude div $mm-per-cm"/>
            </xsl:when>
            <xsl:when test="$from-units = 'cm' and $to-units-clean = 'mm' ">
                <xsl:value-of select="$magnitude * $mm-per-cm"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="magnitude-in-inches">
                    <xsl:choose>
                        <xsl:when test="$from-units = 'mm' ">
                            <xsl:value-of select="$magnitude div $mm-per-inch"/>
                        </xsl:when>
                        <xsl:when test="$from-units = 'cm' ">
                            <xsl:value-of select="$magnitude * $mm-per-cm div
                                $mm-per-inch"/>
                        </xsl:when>
                        <xsl:when test="$from-units = 'in' ">
                            <xsl:value-of select="$magnitude "/>
                        </xsl:when>
                        <xsl:when test="$from-units = 'dpt' ">
                            <xsl:value-of select="$magnitude div $didot-points-per-mm *
                                $mm-per-inch "/>
                        </xsl:when>
                        <xsl:when test="$from-units = 'pt' ">
                            <xsl:value-of select="$magnitude div $points-per-inch"/>
                        </xsl:when>
                        <xsl:when test="$from-units = 'pica' ">
                            <xsl:value-of select="$magnitude div $picas-per-inch"/>
                        </xsl:when>
                        <xsl:when test="$from-units = 'twip' ">
                            <xsl:value-of select="$magnitude div $twips-per-inch"/>
                        </xsl:when>
                        <xsl:when test="$from-units = 'px' ">
                            <xsl:value-of select="$magnitude div $pixels-per-inch"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="$to-units-clean = 'mm' ">
                        <xsl:value-of select="$magnitude-in-inches * $mm-per-inch"/>
                    </xsl:when>
                    <xsl:when test="$to-units-clean = 'cm' ">
                        <xsl:value-of select="$magnitude-in-inches * $mm-per-inch div
                            $mm-per-cm"/>
                    </xsl:when>
                    <xsl:when test="$to-units-clean = 'in' ">
                        <xsl:value-of select="$magnitude-in-inches "/>
                    </xsl:when>
                    <xsl:when test="$to-units-clean = 'dpt' ">
                        <xsl:value-of select="$magnitude-in-inches * $didot-points-per-mm
                            div $mm-per-inch "/>
                    </xsl:when>
                    <xsl:when test="$to-units-clean = 'pt' ">
                        <xsl:value-of select="$magnitude-in-inches * $points-per-inch"/>
                    </xsl:when>
                    <xsl:when test="$to-units-clean = 'pica' ">
                        <xsl:value-of select="$magnitude-in-inches * $picas-per-inch"/>
                    </xsl:when>
                    <xsl:when test="$to-units-clean = 'twip' ">
                        <xsl:value-of select="$magnitude-in-inches * $twips-per-inch"/>
                    </xsl:when>
                    <xsl:when test="$to-units-clean = 'px' ">
                        <xsl:value-of select="$magnitude-in-inches * $pixels-per-inch"/>
                    </xsl:when>
                    <xsl:otherwise> Internal filter error !
                            magnitude-in-inches=<xsl:value-of
                            select="$magnitude-in-inches"/> to-units=<xsl:value-of
                            select="$to-units"/> to-units-clean=<xsl:value-of
                            select="$to-units-clean"/></xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="convert-measurement-units-and-round">
        <xsl:param name="in-value"/>
        <xsl:param name="to-units"/>
        <xsl:variable name="unrounded">
            <xsl:call-template name="convert-measurement-units">
                <xsl:with-param name="in-value" select="$in-value"/>
                <xsl:with-param name="to-units" select="$to-units"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="round($unrounded)"/>
    </xsl:template>

    <xsl:template name="FormatDate">
        <!-- Day is optional. Month and year are always present. 
            Monthname is calculated by locale-dependent lookup.
            Format
            worldwide   day month year
            brazil          day/month/year
            china           year$yearchar month$monthchar day$daychar 
            japan           year$yearchar month$monthchar day$daychar
            korea           year$yearchar month$monthchar day$daychar
            russia          day.month.year
            SSA             day-month-year
            vietnam         day month year
            (Note: $yearchar, $monthchar and $daychar are defined with a leading space)
          -->
        <xsl:variable name="date-spacer">
            <xsl:choose>
                <xsl:when test="//@local-site='russia'">
                    <xsl:value-of select=" '.' "/>
                </xsl:when>
                <xsl:when test="//@local-site='ssa'">
                    <xsl:value-of select=" '-' "/>
                </xsl:when>
                <xsl:when test="//@local-site='brazil'">
                    <xsl:value-of select=" '/' "/>
                </xsl:when>
                <xsl:otherwise>
                    <!--  all other sites -->
                    <xsl:value-of select=" ' ' "/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="thismonthname">
            <xsl:call-template name="MonthName">
                <xsl:with-param name="month">
                    <xsl:value-of select="@month"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="//@local-site='china' or //@local-site='japan'  or
                //@local-site='korea' ">
                <xsl:value-of select="@year"/>
                <xsl:value-of select="$yearchar"/>
                <xsl:value-of select="$date-spacer"/>
                <xsl:value-of select="$thismonthname"/>
                <xsl:value-of select="$monthchar"/>
                <xsl:if test="@day">
                    <xsl:value-of select="$date-spacer"/>
                    <xsl:value-of select="@day"/>
                    <xsl:value-of select="$daychar"/>
                </xsl:if>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="@day">
                    <xsl:value-of select="@day"/>
                    <xsl:value-of select="$date-spacer"/>
                </xsl:if>
                <xsl:value-of select="$thismonthname"/>
                <xsl:value-of select="$date-spacer"/>
                <xsl:value-of select="@year"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- IBS 2012-02-06 Moved xsl:template name="generate-correct-url-form" from dw-common -->
    <!--  6.0 ibs 2010-06-14 Generator template to handle protocol-independent URLs in preview mode -->
    <xsl:template name="generate-correct-url-form">
        <xsl:param name="input-url"/>
        <xsl:variable name="url-prefix">
            <xsl:choose>
                <xsl:when test="$xform-type='preview' and starts-with($input-url, '//')">
                    <xsl:value-of select="'http:'"/>
                </xsl:when>
                <xsl:when test="$xform-type='preview' and starts-with($input-url,
                    '/developerworks')">
                    <xsl:value-of select="'http://www.ibm.com' "/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="concat($url-prefix, $input-url)"/>
    </xsl:template>

    <!-- IBS 2012-02-06 Moved xsl:template name="MonthName" from dw-common -->
    <!-- ======================================
 Template - Monthname
========================================= -->
    <xsl:template name="MonthName">
        <xsl:param name="month"/>
        <xsl:choose>
            <xsl:when test="not(number($month))">
                <xsl:value-of select="$month"/>
            </xsl:when>
            <xsl:when test="$month = '01' ">
                <xsl:value-of select="$month-1-text"/>
            </xsl:when>
            <xsl:when test="$month = '02' ">
                <xsl:value-of select="$month-2-text"/>
            </xsl:when>
            <xsl:when test="$month = '03' ">
                <xsl:value-of select="$month-3-text"/>
            </xsl:when>
            <xsl:when test="$month = '04' ">
                <xsl:value-of select="$month-4-text"/>
            </xsl:when>
            <xsl:when test="$month = '05' ">
                <xsl:value-of select="$month-5-text"/>
            </xsl:when>
            <xsl:when test="$month = '06' ">
                <xsl:value-of select="$month-6-text"/>
            </xsl:when>
            <xsl:when test="$month = '07' ">
                <xsl:value-of select="$month-7-text"/>
            </xsl:when>
            <xsl:when test="$month = '08' ">
                <xsl:value-of select="$month-8-text"/>
            </xsl:when>
            <xsl:when test="$month = '09' ">
                <xsl:value-of select="$month-9-text"/>
            </xsl:when>
            <xsl:when test="$month = '10' ">
                <xsl:value-of select="$month-10-text"/>
            </xsl:when>
            <xsl:when test="$month = '11' ">
                <xsl:value-of select="$month-11-text"/>
            </xsl:when>
            <xsl:when test="$month = '12' ">
                <xsl:value-of select="$month-12-text"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="ReplaceSubstring">
        <xsl:param name="original"/>
        <xsl:param name="substring"/>
        <xsl:param name="replacement" select="''"/>
        <xsl:variable name="first">
            <xsl:choose>
                <xsl:when test="contains($original, $substring)">
                    <xsl:value-of select="substring-before($original, $substring)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$original"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="middle">
            <xsl:choose>
                <xsl:when test="contains($original, $substring)">
                    <xsl:value-of select="$replacement"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="last">
            <xsl:choose>
                <xsl:when test="contains($original, $substring)">
                    <xsl:choose>
                        <xsl:when test="contains(substring-after($original, $substring),
                            $substring)">
                            <xsl:call-template name="ReplaceSubstring">
                                <xsl:with-param name="original">
                                    <xsl:value-of select="substring-after($original,
                                        $substring)"/>
                                </xsl:with-param>
                                <xsl:with-param name="substring">
                                    <xsl:value-of select="$substring"/>
                                </xsl:with-param>
                                <xsl:with-param name="replacement">
                                    <xsl:value-of select="$replacement"/>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="substring-after($original, $substring)"
                            />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="concat($first, $middle, $last)"/>
    </xsl:template>

    <!-- ============================================
        Utility template to strip leading blank lines and trailing white space from code
        in code section,
        New 2011-11-09 IBS
    ============================================ -->
    <xsl:template name="FixCodeSectionWhiteSpace">
        <!-- Process code section. We are missing <pre> elements around code, so this will
            strip extraneous leading blank lines and any trailing white space. -->
        <xsl:for-each select="(*[not(self::heading)]|text())[
            not(following-sibling::heading)]">
            <xsl:choose>
                <xsl:when test="self::text() and (last() = 1)">
                    <!-- Only a single text() block, so strip leading blank
                                    lines and all trailing white space -->
                    <xsl:call-template name="StripTrailingWhiteSpaceFromText">
                        <xsl:with-param name="input-text">
                            <xsl:call-template name="StripLeadingBlankLinesFromText">
                                <xsl:with-param name="input-text" select="."/>
                            </xsl:call-template>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="self::text() and (position() = 1)">
                    <!-- First block is text() and somethign else follows, so
                                    strip leading blank lines -->
                    <xsl:call-template name="StripLeadingBlankLinesFromText">
                        <xsl:with-param name="input-text" select="."/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="self::text() and (position() = last())">
                    <!-- Last block is text(), so strip white space if block
                                    has anything useful in it. -->
                    <xsl:if test="normalize-space(.) != ''">
                        <xsl:call-template name="StripTrailingWhiteSpaceFromText">
                            <xsl:with-param name="input-text" select="."/>
                        </xsl:call-template>
                    </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="."/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
    </xsl:template>

    <!-- ============================================
        Utility template to strip empty lines from beginning of a text string. Does not
        strip leading blanks or tabs from first line.
        New 2011-11-04 IBS
    ============================================ -->
    <xsl:template name="StripLeadingBlankLinesFromText">
        <xsl:param name="input-text" select="."/>
        <xsl:choose>
            <xsl:when test=" (contains($input-text, '&#0010;') and
                (normalize-space(substring-before($input-text, '&#0010;'))
                = '')) ">
                <!-- White space or nothing before first hard new line -->
                <xsl:call-template name="StripLeadingBlankLinesFromText">
                    <xsl:with-param name="input-text" select="substring-after($input-text,
                        '&#0010;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test=" (contains($input-text, '&#0013;') and
                (normalize-space(substring-before($input-text, '&#0013;'))
                = '')) ">
                <!-- White space or nothing before first carriage return -->
                <xsl:call-template name="StripLeadingBlankLinesFromText">
                    <xsl:with-param name="input-text" select="substring-after($input-text,
                        '&#0013;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="(contains($input-text, '&#0160;') and
                (normalize-space(substring-before($input-text, '&#0160;'))
                = '')) ">
                <!-- White space or nothing before first soft new line -->
                <xsl:call-template name="StripLeadingBlankLinesFromText">
                    <xsl:with-param name="input-text" select="substring-after($input-text,
                        '&#0160;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <!-- Some data on first line or empty input -->
                <xsl:value-of select="$input-text"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- ============================================
        Utility template to strip trailing white space from the end of a text string. Will
        strip trailing blanks or tabs from end of last line 
        New 2011-11-04 IBS
    ============================================ -->
    <xsl:template name="StripTrailingWhiteSpaceFromText">
        <!-- Input text - defaults to context -->
        <xsl:param name="input-text" select="."/>
        <!-- Guesstimate of how far back to look for no white space characters. Saves
            normalizing a very long string. -->
        <xsl:param name="strip-length" select="50"/>

        <xsl:variable name="input-length" select="string-length($input-text)"/>
        <xsl:choose>
            <xsl:when test="$input-text='' ">
                <!-- Empty input -->
            </xsl:when>
            <xsl:when test="substring($input-text,$input-length) =
                normalize-space(substring($input-text,$input-length))">
                <!-- Last character is not white space -->
                <xsl:value-of select="$input-text"/>
            </xsl:when>
            <xsl:when test="$input-length > $strip-length">
                <xsl:variable name="stripped-part" select="substring($input-text,
                    $input-length - $strip-length + 1)"/>
                <xsl:choose>
                    <xsl:when test="normalize-space($stripped-part) = ''">
                        <!-- Try again with what's left after stripped part removed -->
                        <xsl:call-template name="StripTrailingWhiteSpaceFromText">
                            <xsl:with-param name="input-text"
                                select="substring($input-text, 1, $input-length -
                                $strip-length)"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- Part that wasn't stripped will be in output -->
                        <xsl:value-of select="substring($input-text, 1, $input-length -
                            $strip-length)"/>
                        <!-- And jsut strip white space from end of stripped part -->
                        <xsl:call-template name="StripTrailingWhiteSpaceFromText">
                            <xsl:with-param name="input-text"
                                select="substring($input-text,
                                $input-length - $strip-length + 1)"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="input-length-norm"
                    select="string-length(normalize-space($input-text))"/>
                <xsl:choose>
                    <xsl:when test="$input-length-norm = 0">
                        <!-- Text is all white space, so quietly drop it.-->
                    </xsl:when>
                    <xsl:when test="$input-length-norm = $input-length">
                        <!-- All white space is already compressed in text -->
                        <xsl:value-of select="$input-text"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- Minimal stuff we want to keep is at least as long as the length of
                    the normalized input string, so keep that much and then call ourselves
                    with the rest. -->
                        <xsl:value-of select="substring($input-text, 1,
                            $input-length-norm)"/>
                        <xsl:call-template name="StripTrailingWhiteSpaceFromText">
                            <xsl:with-param name="input-text"
                                select="substring($input-text,
                                $input-length-norm+1)"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- IBS 2012-02-06 Moved xsl:template name="SkillLevelText" from dw-common -->
    <!-- ======================================
  Skill Level Template: text from skill level attribute 
  ======================================= -->
    <xsl:template name="SkillLevelText">
        <xsl:choose>
            <!-- IBS 2012-02-22 removed single quotes around skill level comparators
                was <xsl:when test="/dw-document//@skill-level = '1' ">
                etc. Saxon 9 complains. Others don't mind.
            -->
            <xsl:when test="/dw-document//@skill-level = 1 ">
                <xsl:value-of select="$level-1-text"/>
            </xsl:when>
            <xsl:when test="/dw-document//@skill-level = 2 ">
                <xsl:value-of select="$level-2-text"/>
            </xsl:when>
            <xsl:when test="/dw-document//@skill-level = 3 ">
                <xsl:value-of select="$level-3-text"/>
            </xsl:when>
            <xsl:when test="/dw-document//@skill-level = 4 ">
                <xsl:value-of select="$level-4-text"/>
            </xsl:when>
            <xsl:when test="/dw-document//@skill-level = 5 ">
                <xsl:value-of select="$level-5-text"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>

</xsl:stylesheet>
